## let和const

1. 不存在变量提升（变量声明前不可用）

2. 暂时性死区（变量声明前，不可复制，注意 *`typeof`不再是绝对安全的*）

   > 当一个变量出现暂时性死区，在使用typeof方法时则会报错，如果是普通的`var`变量，则返回`undefined`

3. 不允许重复声明

   > 相同作用域内不允许重复声明变量，函数内不允许重新定义参数

4. 块级作用域

   > 解决内层变量覆盖外层变量，局部变量泄露为全局变量的问题
   >
   > 解决使用立即执行代码的问题 **( function ( ) { ... } ( ) );**

5. `const`指向一个内存地址，当内存地址内的对象发生改变，`const`不报错

#### ES声明变量的6种方法

- ES5：`var、function`
- ES6：`let、const、class、import`

6. 全局变量不再与顶级对象属性挂钩 `( window.a != let/const a )`

7. 顶级对象`global`

   > 由于在不同环境下的顶级对象差异（浏览器下为`window`，`nodejs`中为`global`），在各种环境中设置顶级对象global使其在所有环境下能够被访问



## 变量的结构赋值

从数组和对象中提取值，对变量进行赋值

#### 数组的结构赋值

1. 等式两边的值必须都是可迭代对象

2. 利用“模式匹配”的方式将可迭代对象拆分赋值

3. 当等式左边只匹配右边一部分的模式，称为“不完全匹配”，也可赋值成功

4. 默认值

   > 结构赋值允许指定默认值，但只有结构变量严格等于 ( === ) `undefined`，默认值才会生效

#### 对象的结构赋值

1. 对象属性无次序，所以要赋值变量名必须与对象属性名相同，一一对应

   > 如果变量名与属性名不一致则必须写成 `let { val : foo } = { foo : 'hello world' }   // foo = 'hello world'`

#### 字符串的结构赋值

> 字符串会被转换为一个类数组对象进行结构赋值

```javascript
const [a,b,c,d,e] = 'hello'    // a='h',b='e',c='l',d='l',e='o'
const {lenth: len} = 'hello'   // lenth=5
```



## 字符串的扩展

#### Unicode字符串方法

1. 字符的`Unicode`表示法（采用大括号的形式解决字符编码上限问题）

2. `codePointAt()`方法正确返回占用4个字节的字符码点（十进制）

3. `String.fromCharCode()`方法正确将码点返回成对应字符

4. 字符串的遍历接口 `for ... of` （能够正确遍历占用4个字节的字符）

5. `normalize()`方法（Unicode 正规化）

   > 许多语言有语调符号和重音符号
   >
   > 在ES5中 直接提供带重音符号的字符 != 合成符号，即原字符与重音符号的合成，两个字符合成一个字符
   >
   > ```javascript
   > '\u01D1'.normalize() === '\u004F\u030C'.normalize()  //ture
   > ```

#### 字符串方法

1. 查询方法

   - **includes()**：返回布尔值，表示是否找到了参数字符串。
   - **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。
   - **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。
2. `repeat( n )`方法：返回一个新的字符串，将原字符串循环n次
3. `padStart(lenth, str)，padEnd(lenth，str)`字符串补全长度方法
4. `matchAll()`方法返回一个正则表达式在当前字符串的所有匹配

#### 模板字符串

1. 模板字符串： \`...` ，可换行，并且会保留所有的空格和缩进

2. 模板字符串绑定变量的方式 ：` ${ value|function }`

3. 模板编译：使用`<%...%>`放置 JavaScript 代码，使用`<%= ... %>`输出 JavaScript 表达式

4. 标签模板

   >将模板紧跟在一个函数的后面，该函数则用来处理这个模板，例如：alert\`hello world\`
   >
   >实质是调用函数的另一种表达形式

5. `String.raw()`方法：处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用



## 数值的扩展

1. 二进制和八进制的表示法：二进制-> `0B|0b`，八进制-> `0o|0O`
2. 十进制转换：`Number( 0b|0o )`
3. `Number.isFinite()`和`Number.isNaN()`方法

   - `Number.isFinite()` 用于查询一个数字是否是有限的，即不是`Infinity`
   - `Number.isNaN()`用于检查一个值是否为NaN
4. ` Number.parseInt(), Number.parseFloat() `从`window`对象移植，功能不变
5. `Number.isInteger()`：判断一个数值是否为整数，非数字类型返回`false`（**超过IEEE754精度以及极限值都会存在误差**）
6. `Number.EPSILON`，常量，等于0.0(52个)1，实际表示JS的最小精度，可以用来设置误差范围
7. 安全整数和 `Number.isSafeInteger()`
   - `Number.MAX_SAFE_INTEGER = 2^53`和`Number.MIN_SAFE_INTEGER = -2^53`：常量，表示JS整数上下限
   - `Number.isSafeInteger()`方法，用于判断数值是否在安全整数范围内

#### Math对象的扩展

1. `Math.trunc()`方法：去除一个数的小数部分，返回整数部分
2. `Math.sign()`方法：判断一个数是正数（返回+1），负数（返回-1），还是零（返回0或-0）
3. `Math.cbrt()`方法：用于计算一个数的立方根
4. `Math.clz32()`方法：将参数转化为32位无符号整数形式
5. `Math.imul()`方法：返回两个数以32位带符号整数形式相乘的结果
6. `Math.fround()`方法：返回一个数的32位单精度浮点数形式
7. `Math.hypot()`方法：返回所有参数的平方和的平方根

##### 对数方法

1. `Math.expm1(x)`方法：返回e^x - 1，即`Math.exp(x)-1`
2. `Math.log1p(x)`方法：返回1+x的自然对数，即`Math.log(1 + x)`
3. `Math.log10(x)`方法：返回以10为底的x的对数
4. `Math.log2(x)`方法：返回以2为底x的对数

##### 双曲函数方法

- `Math.sinh(x)` 返回`x`的双曲正弦（hyperbolic sine）
- `Math.cosh(x)` 返回`x`的双曲余弦（hyperbolic cosine）
- `Math.tanh(x)` 返回`x`的双曲正切（hyperbolic tangent）
- `Math.asinh(x)` 返回`x`的反双曲正弦（inverse hyperbolic sine）
- `Math.acosh(x)` 返回`x`的反双曲余弦（inverse hyperbolic cosine）
- `Math.atanh(x)` 返回`x`的反双曲正切（inverse hyperbolic tangent）

#### 指数运算符

****** ：右结合运算符，多个指数运算符优先算右面的



## 函数的扩展

1. 函数参数的默认值（不能出现同名参数，惰性求值，尽量定义在尾部）

   - `length`属性：返回没有指定默认值的参数个数（如果默认值参数不是尾参数，则只返回默认参数前面未指定默认值的参数个数）

   - 作用域：设置了默认值的参数，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束时，这个作用域会消失。

2. `rest`参数：形式为`...变量名`，该变量名对应一个类数组对象，用于获取函数的多余参数，类似于`arguments`

3. 严格模式：只要函数参数使用了默认值，解构赋值，扩展运算符，那么函数内部就不能显式设定为严格模式

4. `name`属性：返回函数的函数名，匿名函数会返回被赋值的变量名（`Function`构造函数返回的函数实例，`name`属性的值为`anonymous`）

5. 箭头函数：使用箭头定义函数（`“ () => { ... }”`）

   - 函数体内的`this`对象，是定义时所在的对象，而不是使用时所在的对象
   - 不可以当做构造函数，即不可食用`new`命令
   - 函数体内没有`arguments`对象，不可用，可以用`...rest`代替
   - 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。

6. 双冒号运算符：函数绑定运算符，双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为`this`对象绑定到右边的函数上面

7. 尾调用优化：在函数尾部返回调用其他函数，则只保留内层函数调用帧，外层函数由于已经返回不会再用到则不会保留调用帧，所以其内部调用帧会取代外部调用帧

   > ES6的尾调用优化比现在严格模式下开启，正常模式无效。
   >
   > 正常模式下，函数内部有两个变量`arguments`和`caller`，可以跟踪函数的调用栈

8. 尾递归：一个函数返回函数本身进行递归，则只保留一个调用帧，不会出现栈溢出现象

   - 改写：将所有的内部变量改写成函数参数

   > 在严格模式下实现，非严格模式下减少调用栈的方法就是采用循环替代递归

9. 函数参数的尾逗号：允许函数在最后一个参数后面添加一个逗号



## 数组的扩展

1. 扩展运算符（`...`），类似于`...rest`参数逆运算，将一个数组转化为用逗号分隔的参数序列
   - 可以替代函数的`apply`方法
   - 复制数组
   - 合并数组
   - 与解构赋值结合
   - 将字符串转化为数组
   - 可迭代对象