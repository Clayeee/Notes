## let和const

1. 不存在变量提升（变量声明前不可用）

2. 暂时性死区（变量声明前，不可复制，注意 *`typeof`不再是绝对安全的*）

   > 当一个变量出现暂时性死区，在使用typeof方法时则会报错，如果是普通的`var`变量，则返回`undefined`

3. 不允许重复声明

   > 相同作用域内不允许重复声明变量，函数内不允许重新定义参数

4. 块级作用域

   > 解决内层变量覆盖外层变量，局部变量泄露为全局变量的问题
   >
   > 解决使用立即执行代码的问题 **( function ( ) { ... } ( ) );**

5. `const`指向一个内存地址，当内存地址内的对象发生改变，`const`不报错

#### ES声明变量的6种方法

- ES5：`var、function`
- ES6：`let、const、class、import`

6. 全局变量不再与顶级对象属性挂钩 `( window.a != let/const a )`

7. 顶级对象`global`

   > 由于在不同环境下的顶级对象差异（浏览器下为`window`，`nodejs`中为`global`），在各种环境中设置顶级对象global使其在所有环境下能够被访问



## 变量的结构赋值

从数组和对象中提取值，对变量进行赋值

#### 数组的结构赋值

1. 等式两边的值必须都是可迭代对象

2. 利用“模式匹配”的方式将可迭代对象拆分赋值

3. 当等式左边只匹配右边一部分的模式，称为“不完全匹配”，也可赋值成功

4. 默认值

   > 结构赋值允许指定默认值，但只有结构变量严格等于 ( === ) `undefined`，默认值才会生效

#### 对象的结构赋值

1. 对象属性无次序，所以要赋值变量名必须与对象属性名相同，一一对应

   > 如果变量名与属性名不一致则必须写成 `let { val : foo } = { foo : 'hello world' }   // foo = 'hello world'`

#### 字符串的结构赋值

> 字符串会被转换为一个类数组对象进行结构赋值

```javascript
const [a,b,c,d,e] = 'hello'    // a='h',b='e',c='l',d='l',e='o'
const {lenth: len} = 'hello'   // lenth=5
```



## 字符串的扩展

#### Unicode字符串方法

1. 字符的`Unicode`表示法（采用大括号的形式解决字符编码上限问题）

2. `codePointAt()`方法正确返回占用4个字节的字符码点（十进制）

3. `String.fromCharCode()`方法正确将码点返回成对应字符

4. 字符串的遍历接口 `for ... of` （能够正确遍历占用4个字节的字符）

5. `normalize()`方法（Unicode 正规化）

   > 许多语言有语调符号和重音符号
   >
   > 在ES5中 直接提供带重音符号的字符 != 合成符号，即原字符与重音符号的合成，两个字符合成一个字符
   >
   > ```javascript
   > '\u01D1'.normalize() === '\u004F\u030C'.normalize()  //ture
   > ```

#### 字符串方法

1. 查询方法

   - **includes()**：返回布尔值，表示是否找到了参数字符串。
   - **startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。
   - **endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。
2. repeat( n )方法：返回一个新的字符串，将原字符串循环n次
3. 